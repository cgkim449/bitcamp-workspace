# 자바스크립트

## 기초
### 동적 타입 바인딩
- javascript는 값을 [넣는순간] 변수의 타입이 바뀐다

### html한개당 한개의 어플리케이션
웹페이지 한개가 한개의 어플리케이션이다 페이지가 바뀌면 어플리케이션이 바뀐다 그래서 자바스크립트는 특정 웹페이지에서만 사용되기때문에 

## 리턴 타입이없다 당연히 타입이없으니까. 파라미터 타입도 없다
파라미터는 var적으면 안됨
자바와 다르게 자바스크립트는 함수이름이 곧 함수 주소를 갖고잇음

## Object 객체
자바스크립트는 자바처럼 클래스가 없다
Object안에는 값, 함수를 넣을 수 있다
자바스크립트는 함수를 일반 객체로 관리한다
자바는 this를 생략해도되지만 자바스크립트는 안된다

## 제이슨은 자바스크립트의 객체 단축표기법을 흉내내서 만든거다 

## exam 5
버튼 [태그]를 자바스크립트 객체로
[document] : 자바스크립트 내장객체
태그객체를 리턴해준다
예) 버튼객체

태그안의 값을 바꾸고싶으면 [innerHTML]

[돔트리] : 태그객체를 찾는거
태그들이 자바스크립트 객체임
그걸 찾을때 쓰는 메서드

## exam 6 에이잭스
XMLHttpRequest
서버에 요청을 해주는 도구
한마디로 전화기
open 전화기를 드세요
겟요청을 하겟다 누구한테 
send 통화버튼을 누르세요
responsetext에 들어잇다
이게바로 에이젝스

## exam 7
현재테이블에 아무거도없다
테이터가져오기 버튼을 누르면
서버에서 제이슨 형식으로 데이터 가져옴
가져온 데이터를 tr태그를 생성해서뿌림

대괄호는 배열
중괄호는 객체
프로퍼티명 값 프로퍼티명 값 ...
0번째 객체, 1번째 객체, ...인 배열임
responseText안에들어잇는건 원래 걍 문자열임 근데 걔를
자바스크립트 객체로 만들어달라
JSON.parse!!

- - - - - - - 
12-24

- 스크립트 실행하는 중에 오류가 발생하면
즉시 script 태그의 실행을 중단하고 다음 태그로 간다!

이런변수 없어 -> undefined

[함수]안에선언 : 로컬변수, 밖에선언 : 글로벌변수
무조건 함수 안에있냐 밖에 있느냐만!
(블록은 무시한다: 반복문 블록, 조건문 블록 등등)

iterable 객체( for of를 쓸수있다)
- Map

파괴
- 배열

const!!! : const 변수, const 객체
const v2 = new Object();
- 객체의 값을 못바꾼다는게 아니라 객체의 [주소]를 못바꾼다는것!!

let 변수 : 블록! 안에서 로컬변수(함수안의 로컬변수랑 비교하자)
(block-scoped)

---------------------------------------
## 자바스크립트 코드 실행 순서
- 위에서 아래로 태그를 읽는다
- 태그 안에 있는 자바스크립트를 실행하는 중에 오류가 발생하면 즉시! script 태그의 실행을 중단하고 다음 태그로 간다

참고 : jsp: 버퍼에 저장됐다가 jsp 종료시 출력

## 스크립트 태그에 선언된 변수/함수의 [사용범위]
- 애플리케이션(페이지?)

자바스크립트는 인터프리터방식이기 때문에 실행전까지 코드에 오류가 있다는걸 알수없다 즉 실행하는 시점에 문법검사한다

## 리터럴
undefined, null, NaN, Infinity, -Infinity : 전부 상수! 
typeof undefined : 값이 없기 때문에 타입을 알 수 없다
typeof null : object 타입
NaN, Infinity, -Infinity : number 타입

## 호이스팅의 범위
선언문의 소속 스크립트 태그에서만!

참고: console > console setting(톱니바퀴) > preserve log 해제

## window 객체
자바스크립트 언어의 내장객체는 아니다
[웹브라우저]에서 제공하는 기본객체이다
자바스크립트에 선언되는 모든 글로벌 변수와 글로벌 함수는 이 객체에 자동으로 소속된다

[함수밖]에 선언되는 모든 변수는 window 객체에 소속된다
보통 글로벌 변수라고 한다

같은 이름의 변수를 중복 선언하더라도 오류가 아니다
왜냐면 어차피 객체에 맵 방식으로 값을 저장하기 때문에
같은 이름을 가진 변수를 또 선언하더라도
기존의 변수 값을 덮어 쓸 뿐이다

참고 : 자바스크립트 doc 사이트는 MDN 사이트이다

함수스코프 주의!!! 함수안에 블록이있어도 var이면 함수스코프니까!!
함수안에서는 다 똑같은거다!!

----------------------------------------------------

## 배열
자바스크립트의 배열은 자바의 맵 객체를 다루는 것과 유사

var arr = new Array();
1. new : 빈객체를 만든다
2. Object() [객체]에 필요한 최소한의 변수나 함수를 추가한다
    - Array() 함수를 호출하면 내부적으로 Object() 함수를 호출한다
    - 즉 자바의 상속처럼 Array() 생성자는 Object() 생성자를 상속받는다
    - 그래서 Array()를 호출할 때 상위 생성자인 Object()가 호출되는 것이다
3. Array() [배열관리]2에 필요한 변수나 함수를 기본 객체에 추가한다 

- for(;;)
- for(var i in 객체) : 
    - 값이 아닌 프로퍼티를 꺼낸다
        - 배열 : 인덱스르 꺼낸다
        - 객체 : 프로퍼티를 꺼낸다
    - 반복문으로 꺼낼 수 있도록 허가된 프로퍼티에 대해서만 꺼낼 수 있다
    즉 Object() 생성자가 추가한 프로퍼티는 꺼낼 수 없다
- for(var i of iterable객체) : 인덱스가 아닌 값을 꺼낸다
    - 일반 객체는 사용할 수 없다 iterable 객체만 사용가능하다 
        - 배열, Map 등이 iterable객체이다
            - for(var x of obj2) : x가 배열(obj2가 map일때)
            - destructuring

## destructuring - 배열
- 구조분해(얘네 얘네만 받고싶다)
- 순서대로 분해
## destructuring - 객체
- 프로퍼티명으로 분해
- other : 묶어서 하나의 객체로
## destructuring - 함수의 리턴값
- 함수의 리턴값이 배열일때
- 함수의 리턴값이 객체일때 

## const 객체
- 객체의 주소를 못바꾼다는거지 객체의 프로퍼티를 못바꾸는게 아님


# 함수
## 새 변수, 함수를 선언하는게 아니라 값만 바뀐다
    var v1 =100
    var v1=true
    var v1="hello"
    function f1(a)
    function f1()
    function f1(a,b,c)
    그래서 자바스크립트는 함수 오버로딩이라는 개념이 없다

## 함수도 변수와 같이 자동으로 window 객체에 보관됨
- 함수나 변수나 객체 입장에서는 그냥 프로퍼티이다

## 함수 내장변수 arguments
    - arguments는 배열이다
    - Array()로 만든 배열은 [forEach] 함수가 있다
        - 근데 arguments는 Array()로 만든 오리지널 배열이 아니기 때문에
        forEach()가 없다
            - arr.forEach(function(value) {
                console.log(value);
            });
            근데 얘를 정식 배열로 바꿔줄수 있다
            Array.from(arguments);
    - Array()로 만든 배열에는 reduce() 함수가 잇다 : 합계등을 계산할때 유용하다

## 함수와 레퍼런스
- 함수는 객체이다 객체처럼 자유롭게 쓰자, 파라미터로 넘겨줄땐 보통 cb(콜백)라고 한다
    - 즉 프로퍼티와 코드를 갖고 있는 객체이다
        - object = properties(값, 함수, 객체)
        - function = properties + code
          (object + function body)
        참고 : 자바스크립트는 객체지향이 아닌 functional 프로그램
        (function 중심)
## 함수의 호이스팅과 익명함수 (조심!)
    - 변수 선언만 호이스팅된다 할당문!은 같이 안올라온다
## 클로저의 핵심 : 바깥 함수의 로컬변수를 복제
    - 클로저 : 함수 안에서 정의된 함수(return에 있던 어디에 있던 안에서 정의됐으면 무조건 클로저다)
    근데 클로저가 바깥 함수의 로컬변수(파라미터 등)을 사용한다면
    그럼 알아서 복제해둔다 이게 핵심임
## 클로저를 객체에 담아 리턴할수있다
## 익명함수를 정의할때 arrow functioin 문법을 사용할 수 있다(람다임)
## 애로우 함수를 아규먼트로 전달하기
## 애로우 함수를 리턴하기
## 함수도 객체이기 때문에 프로퍼티를 추가 할 수 있다
        - f1() : f1함수 객체에 저장된 함수 코드를 실행하라!

- 16
- 17
----------------------------------------

2020/12/28...

4
## 1 객체 정의
자바의 맵객체와 똑같은 방식이다

1. 완전한 빈 객체를 만든다
var obj = Object.create(null); 
// Object는 클래스가 아니라 함수객체다
// create는 함수객체에 소속된 함수이다
// 완전한 빈 객체를 만든다

2=3=4
2. 빈 객체를 만든 후 기본 메서드(생성자)를 호출하여 [필수프로퍼티(변수와함수)] 등을 추가한다.
var obj2 = Object.create(Object.prototype);

3. var obj3 = new Object();
4. var obj4 = {};


## 객체에 소속된 함수가 그 객체에 소속된 멤버 사용하기 즉 동등한 위치의 멤버 사용하기
- this를 꼭 써야한다(this.멤버)
(자바에선 생략가능)
    - console.log는 겍체의 주소를 주면valueOf의 리턴값을 출력(valueOf는 기본객체에 들어있는 함수다)
    - 자바의 println한테 객체 주소를 주면 내부적으로 toString()의 리턴값을 출력하지만.

## 조심! arrow function은 기본적으로 글로벌 함술에 소속되기 때문에 this가 가리키는 것은 window 객체이다
- 객체의 멤버로 함수를 추가할때는 애로우 펑션을 걍 쓰지마라

## 자바스크립트는 생성자라는  문법이 따로 없다 그냥 new다음에 함수를 호출하면 된다
- 일반 함수를 생성자처럼 사용한다
    - new 명령을 사용하여 외부에서 빈 객체를 생성한 후 일반 함수를 호출한다
    - 외부에서 생성한 객체는 this를 통해 접근할 수 있다
    - 만약 new 명령없이 이 함수를 호출한다면 this는 undefined이다

클로저끼리는 복제 변수를 공유한다

## DOM API
- 핵심
    - 태그를 자바스크립트 객체로 만든다 그래서 DOM이다 이때 생성자 함수를 이용하는데 얘의 상속관계가 있다 Object가 추가한 프로퍼티, ~가 추가한 프로퍼티, ~가 추가한 프로퍼티...

### 태그를 찾고싶다!
- id getElement!!!
- 이름 getElement's'!!!
    - HTMLCollection : 배열아니다(주의) 근데 iterable 규칙을 구현했기 때문에 for ...of는 쓸수있다(for ...in은 못쓰지만)
- 분류명으로 찾자
- css selector로 찾자
    빈 노드리스트 리턴(null이 아니다)
    - id로 찾자
    - 이름으로 찾자
    - 분류명으로 찾자

### 태그 콘텐츠!
### 태그 속성!
### 태그 추가 삭제!
### appendChild() 응용

## 이벤트
이벤트가 발생됐을때 호출될 함수
4가지방법




-----------------------------------------
12-29

에이젝스

웹브라우저가 웹서버에게 요청을하고 웹서버는 응답을 하는데
보통 이건 html+css+javascript 이다
이 응답내용을 받아서 브라우저가 화면에 뿌린다(렌더링)
화면을바꾸고싶으면 또 요청 또 응답 또 렌더링 한다
근데 화면의 일부분을 변경하고싶다(전체화면이아니라)
기존화면을 그대로 냅두고 별도로 요청하자

그래서 이렇게하자
[스레드]한테 위임하자(일부분을 가져올걸)
브라우저가 [스레드]를 띄운다
그리그 그 스레드가 웹서버에게 요청한다
웹서버가 그 요청에 대해 응답을 한다
그리고 그 스레드가 그 일부화면을 갱신한다
렌더링은 항상 브라우저가

우리프로젝트:
기존화면을 내비두고 상세화면을 다이얼로그로 띄우고싶다

스레드가 자바스크립트를 사용해서 비동기로 작업한다

웹서버가 데이터를 줄때 html+css+javascript, xml,json을 준다
그래서 ajax
근데 요즘은 ajax보단 json형식을 더 많이씀

서버가 json을 보내면 자바스크립트가 그걸 처리한다
자바스크립트가 dom api ( create ~)사용해서 처리함
list3는 배달의민족
list2는 si

# ex07
window객체의.location객체의.href라는프로퍼티

스레드를 만드는방법 : XMLHttpRequest()
- 동기/비동기 HTTP 요청을 할 때 사용한다

false : 동기방식 - 서버에서 응답할때까지 스레드가 브라우저에게 리턴하지 않는다(스레드가 브라우저에게)
비동기는 위임받자마자 리턴
동기는 위임받고 스레드가 서버에 요청하고 응답받고 리턴

## 에이젝스 요청의 제약
CORS : 교차 출처 리소스 공유

## 에이젝스 요청과 프록시
브라우저가 daum한테 에이젝스 요청
당연히 cors제약에 따라 차단
그럼 해결책은?
브라우저가 서버에 에이잭스 요청
서버가 대행(http요청을 대행) 다음이 응답 서버가 브라우저에게 응답
이 방법밖엔 없다
자바스크립트의 에이잭스요청은 cors 정책에 제약을 받지만
직접 프로그램에서 http 요청하는 것은 제약이 없다



