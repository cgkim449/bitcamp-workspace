### 제발
static
1 한글을 쓰자(중첩)
2 쉬운 언어를 쓰자(안에 있는)
3 나만의 언어로 정리하자(남에게 보여주는 용도가 아님)

### 흐름
1 무조건 흐름부터 파악(흐름 파악안되면 치지말자)
2 치라고 무조건 치지말자
------------------------------------------
1 top-level class

2 static nested class = top-level class
유지보수 좋게 끔 안에 넣은거 뿐
안에 종속되는게 아님

3 non- static nested class = inner class 
B는 A에 종속됨
그래서 A를 만들지 않고 B를 만들 수 없음

4 local class

5 anonymous class (익명 클래스)
클래스를 좀더 간단하게 만드는 문법
-------------------------------------------
e 로컬클래스를 익명클래스로 바꾸는건가

### 로컬클래스로 클래스 안에 있는 인터페이스 구현(인터페이스는 스태틱으로 선언 안해도 스태틱 멤버에서 사용가능하다, 즉 인터페이스는 스태틱 빼고 선언하자)
A obj = new My(); // 로컬클래스가 인터페이스를 구현하여 객체를 생성해서 인터페이스의 레퍼런스가 가리키고 있다 

### 익명 클래스로 클래스 안에 있는 인터페이스, 추상 클래스 구현
A obj = new A() {인터페이스 or 추상클래스 구현}; 
// A가 익명클래스의 인터페이스 or 추상클래스 // 생성자는 누구의 생성자? Object?

### 익명클래스로 클래스 안에 있는 클래스를 상속
A obj = new A() {}; // A가 익명클래스의 수퍼클래스 // 생성자는 A의 생성자
A obj = new A() {A의 메서드를 오버라이딩}; // A가 익명클래스의 수퍼클래스 // 생성자는 A의 생성자 

### 익명클래스로 클래스 안에 있는 클래스를 상속 + 그 클래스의 메서드를오버라이딩
static A obj = new A() {A의 메서드 오버라이딩};
A obj = new A() {};
A obj = new A() {};

###400 클래스, 메서드 안에서 변수 선언하고 익명 클래스를 사용하여 할당해보자
- 410 클래스안에 스태틱 변수 선언하고 할당할때 익명 클래스 사용
- 420 클래스안에 인스턴스 변수 선언하고 할당할때 익명 클래스 사용
- 430 클래스안에 메서드안에 로컬 변수 선언하고 할당할때 익명 클래스 사용
- 440 430처럼 번거롭게 안에서 로컬 변수 선언하지않고, 파라미터에 로컬변수 선언하고 할당할때 익명 클래스 사용


123 
4 클래스 이름 없어서 인스턴스 생성할 수 없음 바로 생성해야됨?
5 이름이 없기 때문에 생성자가 없어서 수퍼 클래스!의 생성자를 호출해야함
(클래스 이름이 없으면 생성자 못 만듬)
6 익명 클래스의 레퍼런스 선언
클래스 이름이 없어서 레퍼런스를 선언 못함
그래서 익명 클래스가 구현하는 인터페이스!나 
익명클래스가 상속받는 수퍼 클래스!로 선언해야함

0310 
final 값을 외부에서 한번 받고 바꾸지 못하게 하겟다(조회용도로만 하겟다)
(컴파일 단계에서 잘못된 사용을 미리 걸러낼 수 있어서 클린 코딩이 가능해진다 로버트 C 마틴 클린코딩)
320
410
class ? implements A() {} // 인스턴스를 바로 만든거다
420
440

f
나중에

g
- step7 : (스태틱중첩클래스의 응용)이래서 스태틱 중첩 클래스 사용하는것
- Category 클래스 안의 중첩 클래스들은 이름을 소문자로 한다(예 : 구글 안드로이드 R.java)
    - 다나와 카테고리처럼
    
------------------------------
# pms : 객체를 한번 밖에 안만들거면 익명클래스를 쓰자
pms 로컬클래스의 객체 만들어서 사용했었다
pms 근데 로컬클래스 객체를 한번밖에 안만들거면 익명클래스를 쓰자
이름을 날리자
이름을 날리다(Iterator<E> 앞에 다 삭제)
이름을 날렸기에 바로 인스턴스를 생성해야한다
Iterator 레퍼런스 선언
할당
return Iterator 레퍼런스
근데 Itertaor 레퍼런스 선언할 필요가 있냐고
그래서 바로 `return 익명 클래스 인스턴스` 하자

Queue
근데 이름이 없으면 생성자가 있을 수 없네
이때쓰라는게 인스턴스 블럭!!
인스턴스 블럭은 생성자 안에 코드가 삽입된다
컴파일러가 생성자를 내부적으로 만든다
인스턴스 블럭은 다른데서 거의 쓸일이 없다

inner class 메서드? 안에는 static 사용못함?

익명클래스도 클래스 파일 당연히 있다
익명클래스는 이름이 없어서 AbstractList$1(순서대로), $2, $3,... 이렇게 bin폴더에 클래스 파일 생성

e.220 : 
익명클래스가
수퍼클래스와 인터페이스를 동시에 상속, 구현할 수 있을까?
추상클래스와 인터페이스를 동시에 상속, 구현할 수 있을까?
: 안됨
static abstract class A { 추상메서드 print()}

interface B {추상메서드 getName()}

static main{
클래스도 상속받고 인터페이스도 구현하는 익명 클래스를 만들 수 있을까?
// 안됨
// 둘 중 하나만 상속받거나 구현해야지, 동시에 다 할 수 없다

A obj = new A implements B() {
print() 구현
getName() 구현
}

e.230 : 여러개의 인터페이스를 구현할 수 있을까?
: 안됨

d.130
m1의 로컬 클래스 X는 컴파일 하면 이름이 어떻게?
m2의 로컬 클래스 X는 컴파일 하면 이름이 어떻게?
B2$1X, B2$2X
-------------------------------------------------
# pms-27
- 자바에서 제공하는 컬렉션 API의 사용법을 익히자
- 내부구조를 이해하자(했었음)
    - ArrayList remove!!
1 교체하자
- util 패키지에서 prompt말고 전부 삭제
- handler 클래스들 ctrl shift o만 하면 끝! (똑같이 만들었었음)
- app 클래스 ctrl shift o, Queue는.. 
원래 인터페이스다 LinkedList가 Queue를 구현한다
Queue 레퍼런스로 LinkedList 객체 생성해서 가리키자
Stack도 컴파일 오류는 안나지만 문제가 있다
실행해서 history해보자
그럼 입력한 순서대로 나온다
history2는 입력한 순서대로 나오는게 맞다
Stack은 Vector를 상속받았다
원래 iterator는 역순으로
Vector가 리턴하는 iterator는 순서대로기 때문
그래서 Deque(De : 반대, que : Queue) 레퍼런스로 ArrayDeque 객체 가리키자 
(더 완전한 consistent set(구성? 셋) is provided by the Deque interface and its implementations)
----------------------------------------------------
복습 : 캡슐화 : 
1 기능을 빼내는것
2 기능 코드를 private, protected 등으로 감추는 것
----------------------------------------------------
pms-28 커맨드 패턴 : 메서드의 객체화, 메서드의 캡슐화
현재방식 : 명령어가 추가되면 메서드를 추가해야한다(즉 기존코드를 손대야 한다(위험성 내포)) (예: /board/search추가 -> search()추가)
명령어가 추가됐을때 기존코드를 손대지 않고 메서드를 추가하고 싶다
=> 메서드를 클래스!로 만들자
그럼 새로운 명령어가 추가되면 새로운 클래스를 만들면 된다
그럼 기존의 코드를 손대지 않고 메서드를 추가할 수 있다
이것이 커맨드 패턴

커맨드 패턴 : "메서드를 객체화" 또는 "메서드를 캡슐화" (직관적으로는 메서드를 클래스화)
그럼 클래스가 늘어나서 유지보수가 어려워지는거 아닙니까? ㄴㄴ 
그거보다 기존 기능을 얼마나 빠르게 추가하고 빠르게 삭제할수있냐 이게 더 중요

커맨드 패턴의 전제조건 : 명령어 하나당 메서드 하나를 추가할 때

0단계 : 커맨드 패턴 적용전
/board/search를 추가하면 search()를 추가

1단계 : 사용자 명령을 처리하는 메서드의 호출 규칙을 정의한다
package com.eomcs.pms.handler;
public interface Command {
  void execute();
}

2단계 : XxxHandler의 각 메서드를 Command 구현체로 분리한다 
BoardAddcommand 클래스 추가
Command 구현
execute() 재정의(오버라이딩) : BoardHandler의 add랑 똑같이
그럼 boardList 객체를 사용해야한다
boardList 레퍼런스 선언
boardList 객체를 생성자로 주입
끝
3단계 : 
4단계 : /hello 명령을 추가해보자

app에는 코드를 추가할 수 밖에없다 근데 이거마저 나중에 없앨거다 Spring ioc?

커맨드패턴을 적용하여 애플리케이션 아키텍처를 변경하였다
커맨드 패턴을 적용할 경우 새기능 추가가 쉽다는 것을 확인해보자
---------------------------------------------------------------
# 원래 그 문법의 성질을 바꾸게 하는 것 public, private, final 등을 modifier이라함
에러 : duplicate modifier-
------------------------------
hashtable hashmap이 Map 구현함
// 커맨드 객체를 저장할 맵 객체
Map<String,Command> commandMap = new HashMap<>();
// 맵 객체에 커맨드 객체를 보관한다

switch해서 명령어를 찾으면 호출하고 못찾으면 안함
history 위로 다 지워?
