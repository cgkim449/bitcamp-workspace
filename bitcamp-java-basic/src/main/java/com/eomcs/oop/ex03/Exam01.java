// ## 메서드 = 요리,
// static : 그릇이 static 영역에 있습니다, 없을수도있고, 아무튼 그래서 그릇 안줘도 됩니다
// 재료만 주십쇼, 안줘도되고
//
// - static method : 그릇이 static 영역에 있다, 따라서 그릇 한개만 리턴 가능, 재료만 파라미터로 받음
// 예) Date.valueof("2020-02-02");
//     System.currentTimeMillis();
// - instance method : 그릇과 재료 둘다 파라미터로 받음, 따라서 그릇 여러개 리턴 가능,
//                     그릇은 재료랑 다른 방식으로 받음
// - 설명 쉽게할려고 이렇게 한거지 사실 그릇 리턴안하는 메서드, 재료 안 받는 메서드 등 다양함
//---------------------------------------------------------------
// ## static 변수의 사용 예 : 상수, 카운트
// - 상수를 스태틱 변수로 많이 사용한다, 왜냐면 인스턴스 변수로 사용하면
// 인스턴스가 생성될때마다 계속 상수 필드도 생성되는데 그게 불필요하기 때문이다
// - 카운트도 스태틱 변수로 많이 사용한다, 자동차를 생성할때마다 그 숫자를 카운트하기위해서다
//---------------------------------------------------------------
// ## 클래스 로딩
// 1) 클래스 파일을 찾는다.
//    - JDK가 설치된 폴더의 하위 폴더인 /lib에서 찾는다.
//    - OS의 CLASSPATH 환경 변수에 설정된 디렉토리를 탐색하여 찾는다.
//    - JVM을 실행할 때 -classpath 또는 -cp 옵션으로 설정된 디렉토리를 탐색하여 찾는다.
//    - JVM을 실행하는 현재 폴더에서 찾는다.
//    - 그래도 없으면 오류를 띄운다.
// 2) 클래스 파일 검증
//    - bytecode의 유효여부를 검사
// 3) 클래스를 Method Area 영역에 로딩
//    - 코드(생성자, 메서드) 보관
//    - 상수 보관(스태틱 영역에 ??)
//    - 스태틱 필드 생성
// => 클래스는 딱 한 번만 로딩된다. 중복 로딩되지 않는다.
//----------------------------------------------------------------
// 클래스변수는 클래스가 로딩되는 시점에 Method Area에 생성된다.
    // 클래스가 로딩되는 때?
    // - 로딩되지 않은 클래스를 사용할 때
    // - 클래스 변수(스태틱 변수)를 사용하거나 클래스 메서드(스태틱 메서드)를 사용하려 할 때
    //

//-----------------------------------------------------------------
//## 클래스 로딩
//- 외부 저장장치(예: HDD, USB 메모리, DVD-ROM 등)에 있는 .class 파일을
//JVM이 관리하는 메모리로 로딩하는 것.
//- 클래스의 코드를 사용하는 시점에 메모리(Method Area 영역)에 로딩된다.

//## 클래스의 코드를 사용하는 시점?
//- 스태틱 멤버(필드와 메서드)를 사용할 때
//예) A.v1 = 200;
//예) System.out.println(A.v1);
//예) Integer.parseInt(..);
//- new 명령을 사용하여 인스턴스를 생성할 때
//예) new A();
//- 한 번 로딩되면 JVM을 종료할 때까지 유지한다.
//- 물론 강제로 unloading 할 수 있다. 그리고 다시 로딩할 수 있다.

//## 클래스를 로딩할 거라고 착각하는 경우
//- 다음과 같이 레퍼런스 변수를 선언할 때는 클래스를 로딩하지 않는다.
// 로딩하지 않는다! 로딩하지 않는다! 로딩하지 않는다!
//예) A obj;
//예) String str;

//## 클래스 로딩 과정
//$ java com.eomcs.oop.ex03.Exam0130
//1) Exam0130.class 를 "Method Area 영역"에 로딩한다.
//- 클래스를 외부 저장소에서 내부 저장소인 RAM으로 로딩한다.
//2) 바이트코드 검증(Verify)
//- 클래스의 바이트코드 유효성을 검사한다.
//3) 스태틱 필드 및 메서드 테이블 준비(Prepare)
//- 스태틱 메모리나 클래스 내부에서 사용하는 이름(변수명, 메서드명, 클래스명 등) 목록을 준비한다.
//4) 참조하는 외부 클래스나 인터페이스 검사(Resolve)
//- 다른 클래스나 인터페이스를 참조하는 것이 유효한지 검사한다.
//5) 클래스 초기화시키기
//- 변수 초기화 문장(variable initializers), 스태틱 블록(static initializers)을 실행한다.
//6) main() 메서드를 호출한다.
//- 해당 클래스의 main() 메서드를 실행한다.

//## Exam0130의 main() 메서드 호출
//1) main() 메서드에 선언된 로컬 변수를 "JVM 스택 영역"에 생성한다.
//- args 변수를 스택 영역에 생성한다.
//2) main()의 코드를 실행한다.
//- A.v1 = 100;
//- A.class 를 "Method Area"에 로딩한다.
//- A의 클래스(스태틱) 필드를 "Method Area"에 생성한다.
//- `A.v1 = 100` 문장을 실행한다.
//- A.v2 = true;
//- A 클래스가 이미 로딩되었기 때문에 다시 로딩하지 않는다.
//- `A.v2 = true` 문장을 실행한다.
//- System.out.println() 를 실행한다.
//

//## JVM이 관리하는 메모리 영역
//1) Heap
//- new 명령으로 생성한 인스턴스가 놓인다.
//- 즉 인스턴스 필드가 이 영역에 생성된다.
//- 가비지 컬렉터는 이 메모리의 가비지들을 관리한다.
//2) JVM Stack
//- 각 스레드가 개인적으로 관리하는 메모리 영역이다.
//- 스레드에서 메서드를 호출할 때 메서드의 로컬 변수를 이 영역에 만든다.
//- 메서드가 호출될 때 그 메서드가 사용하는 로컬 변수를 프레임에 담아 만든다.
//- 메서드 호출이 끝나면 그 메서드가 소유한 프레임이 삭제된다.
//3) Method Area
//- JVM이 실행하는 바이트코드(.class 파일)를 두는 메모리 영역이다.
//- 즉 클래스 코드가 이 영역에 놓이는 것이다.
//- JVM은 코드를 실행할 때 이 영역에 놓은 명령어를 실행하는 것이다.
//- 주의! Heap에는 개발자가 작성한 명령어가 없다.
//- 개발자가 작성한 클래스, 메서드 등 이런 코드들이 이 영역에 놓이는 것이다.
//- 스태틱 필드를 이 영역에 생성한다.
//
package com.eomcs.oop.ex03;

public class Exam01 {
  public static void main(String[] args) {
    class A {

    }
  }
}
