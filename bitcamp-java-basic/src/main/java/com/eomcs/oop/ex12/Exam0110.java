// Lambda 문법 - 익명 클래스 vs 람다

// 익명클래스 중에서도 추상메서드가 한개인 인터페이스, 를 구현, 할때 좀더 간단히 표현하기 위해 만든 문법

// Lambda 문법 - functional interface를 효과적으로 다루는 문법
// 자바는  코딩의 최소단위가 클래스다
// 그니까 메서드를 만들더라도 클래스를 만들고 넣는거지
// 메서드를 따로 못만든다
//C같은 경우는 클래스가 없어도 된다 
// 그냥 함수를 바로 작성하면 된다
//클래스란 문법이 도입된이유 : 코드가 점점 커지면서 수많은 펑션을 관리하기 너무 어려워서
//클래스 단어 뜻 자체 : 분류
//대량의 코드를 관리하기 쉽게하기 위해서 클래스가 등장
//근데 코딩하다보면 때로는 간단한 함수를 다루고 싶을때가 있다
//그래서 옛날 C를 그리워함
//그래서 객체지향을 하다가 
//람다식을 만듬
//다른언어는 간단한 함수 만드는데
//자바는 메서드 만들고 클래스도 만들어서 그 클래스에 꼭 넣어야되니까 힘들다
//그래서 흉내내기위해 등장한게 람다문법
package com.eomcs.oop.ex12;

public class Exam0110 {

  // 다음과 같이 추상 메서드가 한 개 있는 인터페이스를 "functional interface"라고 부른다.
  // => 이런 경우에 람다 문법으로 사용할 수 있다.
  // => 인터페이스는 static 을 붙이지 않아도 static 멤버가 사용할 수 있다.
  interface Player {
    void play();
  }

  public static void main(String[] args) {

    // 익명 클래스로 인터페이스 구현하기
    Player p1 = new Player() {
      @Override
      public void play() {
        System.out.println("익명 클래스");
      }
    };
    p1.play();
    //    Player p1 = /new Player/() +->+ {
    //      /@Override
    //      public void play() {/

    //        System.out.println("익명 클래스");

    //      /}/
    //    };

    // 람다 문법으로 인터페이스 구현하기
    Player p2 = () -> {
      System.out.println("람다");
    };
    p2.play();

    // 궁금한게 있다
    // 처음에 람다가 등장했을때는 익명클래스처럼 별도 클래스 파일 생김
    // 근데 버전9때부터인가 클래스파일이 안만들어져!
    // 람다가 내부에 메서드로 처리돼!!!
    // 
    // 익명클래스와 .class파일
    // => 자바의 nested class는 모두 별도의 .class 파일을 갖는다
    // => 위의 main에 정의된 로컬 익명 클래스는 다음과 같은 이름의 .class파일로 컴파일 된다
    // Exam0110$1.class

    //람다와 .class파일
    // => 람다는 해당클래스의 멤버 메서드로 정의된다
    // => 즉 별도의 .class파일을 생성하지 않는다
    // => 람다 문법이 초기에 등장했을 때는 익명 클래스로 변환 되었다
    // => 그러나 최근에는 그냥 멤버 메서드로 변환된다
    // => 예) git pull하자
    // => 람다른 호출하는 코드는 자동 생성된 메서드를 호출하는 코드로 변환된다
  }
}


