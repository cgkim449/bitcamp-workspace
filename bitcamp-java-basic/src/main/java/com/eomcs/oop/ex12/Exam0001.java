// 01 객체를 할당하는것이다, 메서드의 리턴값을 할당하는게 아니다 착각하지말자, 근데 ()는 추상메서드의 파라미터다 생성자가 아님

// - 생략 : 람다를 만드는 이유가 생략하고 싶은걸 전부 생략하기 위해서다, 파라미터 타입 같은거
// - 람다식으로 익명클래스 객체 생성하고 
//  - 이너클래스를 익명으로? : 스태틱 필드 or 인스턴스 필드 준비, 
//  - 로컬클래스를 익명으로 : 메서드의 로컬변수 준비, 메서드의 파라미터 준비에 사용하자!!!
// 
// 02 인터페이스의 메서드가 여러개 있다고해도 추상메서드가 한개이기만 funtional interface라고한다

// - 언제 람다식을 쓸까 : = 익명클래스인데 인터페이스가 functional interface일때
// 
// 예) 로컬클래스를 람다식 익명클래스로
// 여기 메서드 안에서만 쓸 클래스 즉, 로컬 클래스인데 어떤 클래스냐면 중첩인터페이스를 구현하고, 그걸 한번만 생성해서 쓸거야
// 1인터페이스를 구현하여 2한번만  생성하고 0이메서드 안에서만 사용할 꺼니까 당연히 익명클래스로 쓰는것
// 근데 거기다가 인터페이스를 보니까 3추상메서드가 한개밖에 없다
// 그럼 람다식 쓰면 되겠네

// - 람다식을 써보자
// 익명 클래스라고 생각하자
// 1 일단 익명 클래스니까 당연히 레퍼런스를 인터페이스로 선언 해야지
// 2 그담에 괄호 다 만들고 세미콜론찍자 할당문이니까

// 3 그담에 파라미터 넣고(타입 생략해서)
// 4 메서드 바디 구현하자
// 5 괄호 생략할 수 있으면 하자(파라미터 한개이거나, 바디 코드 한문장일때)

// 6 다 만들었으면 이제 객체를 사용하자
// 사용한다는것은 그 객체의 메서드, 필드를 사용한다는것
// 인터페이스를 구현한 것이므로 디폴트 메서드도 사용가능
//
// 03 람다 활용 - 아규먼트에 람다 넣으면 직관적이다!
// 예) 로컬클래스가 정의된다음 생성되서 아규먼트에 들어가있다
// 익명클래스를 정의생성 한다음 그걸 그대로 아규먼트에 넣어버리면 간단
// 아니면 첨부터 아규먼트에서 익명 클래스 정의생성하며됨

// 근데 functional interface면 람다로 써버림
// 더간결하고
// 더 직관적! test(구현메서드(구현체)) // test {sysout()}
//
// 중첩인터페이스를 구현한 로컬 클래스를 정의
// 구현한 메서드를 테스트!하기 위해 로컬클래스를 아규먼트로 넣는 test메서드 만듬
// test메서드를 Exam0000의 스태틱 메서드로 만들면 파라미터로 MyPlayer를 찾을 수 없으므로(로컬클래스니까)
// 인터페이스로 바꿔줌
// 그리고 받은 로컬클래스 객체.구현한 메서드() 한줄 넣자

//    test(); // 만든 구현체를 파라미터로 받아서 그 구현 메서드를 테스트하고싶어서 이런 메서드 만들거야
//    test(); // 로컬클래스는 정의한담에 생성하기때문에 아규먼트에 한번에 못넣는단말이지
//    test();//근데마침 한번만 생성할꺼니까 익명클래스로 만들잔말이지 그럼 아규먼트에서 정의생성할수있어서 매우 간결
//    test(); // 아니 근데 보니까 중첩인터페이스가 funtional interface란말이지 그럼 람다쓰면 더 간결, 더 직관적
//    test((a,b) -> a + b); // 직관적이다 이런 구현한 메서드 테스트해보자
package com.eomcs.oop.ex12;

public class Exam0001 {
  static interface Calculator {
    int compute(int a, int b);
  }
  public static void main(String[] args) {
    test((a,b) -> {
      int sum = 0;
      for (int i = a; i <= b; i++) {
        sum += i;
      }
      return sum;

    });

  }
  private static void test(Object object) {
    // TODO Auto-generated method stub

  }
}