# DB모델링

## 설치
exerd.com > 다운로드 > 이클립스 플러그인으로 설치 > 맨위 복사 > 이클립스 help> install new software 
name exerd, 아까 경로 복붙 > add > 체크 > contact all update 체크 x(
업데이트할거 다 설치해서 한시간걸림) > 무조건 예스 > 이클립스 리스타트

// 이클립스 설치하면 워크스페이스 utf-8로 바꾸자

## 주요 용어
모델링 : 글과 그림으로 표현한것
렌더링 : 명령어를 해석하여 화면에 출력하는것

table(relation; entity; file)
intension(schema; header) : 클래스 : 데이터 구조 설계도
extension(instance; data) : 인스턴스 : 데이터
row(tuple; record) : 데이터 한개(여러컬럼으로 이루어진)
column(attribute; field) : 데이터의 한 항목


컬럼!!!
## 키 : 데이터 식별 가능
- 슈퍼키
- 데이터를 구분할 때 사용할 식별자(id entifier)
- 한개이상의 [컬럼]으로 구성
예)
1 이름 학과 학번
2 이름 학과 전화


## 후보키(pk의 후보들)
- 슈퍼키들 중에서 선별된 최소키
- 최소키 : 최소한의 컬럼 값 만으로 식별이 가능한 키
예) 최소로 줄인다
1 학번
2 이름 전화

## pk & 대안키(uk로 설정)
## 인공키
- pk의 컬럼 수가 많거나, pk로 사용할 적당한 키가 없는 경우 
예) 페이스북 이메일 = uk, 일련번호 = 인공키

pk는 아니지만 값이 중복되면 안되는 컬럼 = uk

## fk
- 다른 테이블의 [pk]값을 저장하는 컬럼

- - -

## 논리모델
- dbms 고려않고 수행하는 개념적인 모델링

### 테이블(엔티티) 식별, 컬럼(속성attribute) 식별

- - -

# DB 모델링
- 모델링? 분석하고 구조화시켜 생각한 바를 글과 그림으로 표현한 것.
- 렌더링? 명령어를 해석하여 화면에 출력하는 것.
  예) HTML 렌더링 => HTML 태그를 해석하여 그에 해당하는 UI를 출력하는 것.
- DB 모델링? 데이터를 분석하고 구조화시켜 데이터 속성과 관계를 글과 그림으로 표현한 것.
- 목표? 데이터가 중복되지 않도록 테이블을 구조화하는 것.
- 중복 데이터를 제거 ==> 데이터의 안정성, 신뢰성을 높인다. ==> 무결성을 유지한다.

## 주요 용어 p.76
- table(relation; entity; file)
- intension(schema; header) => 데이터 구조 설계도
- extension(instance; data) => 데이터
- row(tuple; record) => 데이터(여러 컬럼으로 이루어진) 한 개. 예) 학생
- column(attribute; field) => 데이터의 한 항목. 예) 이름, 학번, 전화번호

## 키(key) p.80
- 데이터를 구분할 때 사용할 식별자.
- "수퍼 키(super key)"라 부르기도 한다. 
- 식별자? 
  - 데이터를 구분할 때 사용하는 값.
  - 한 개 이상의 컬럼으로 구성된다.
  - 식별자를 key라고 부른다.
  - 예) 학생(학번, 이름, 전화, 이메일, 학과, 우편번호, 주소, 주민등록번호) 
    - 학번 (O)
    - 주민등록번호 (O)
    - 이메일 (O)
    - 전화 (X)
    - (이름,전화) (O)
    - (이메일,이름) (O)
    - (이름,학과,학번) (O)
    - (이름,학과,전화) (O)
    
### 후보키(candidate key) 선정 p.82 ~ 83
- super key 들 중에서 선별된 최소키를 가리킨다.
- 최소키? 최소한의 컬럼 값 만으로 식별이 가능한 key.
- 수퍼 키 예)  
  - 학번 (O)
  - 주민등록번호 (O)
  - 이메일 (O)
  - (이름,전화) (O) => 이름과 전화 값을 묶은 것 보다 적은 개 수의 후보 키가 있다면 가능한 제외하라!
  - (이메일,이름) (X) => 이메일 만으로 식별 가능
  - (이름,학과,학번) (X) => 학번 만으로 식별 가능
  - (이름,학과,전화) (x) => 이름과 학과, 전화 보다 더 적은 컬럼의 후보 키가 있기 때문에 가능한 제외한다.

### 기본 키/주 키(primary key; PK) 선정 p.83
- 후보키 중에서 데이터 식별자로 사용하기 위해 선정된 키.
- 나머지 후보키는 대안키(alternate key)라 부른다.
- 왜? 비록 PK는 아니지만 PK와 마찬가지로 데이터 식별자로 대체하여 사용할 수 있기 때문이다.  
    
### 대리 키(surrogate key)/인공 키(artificial key)
- 주 키의 컬럼의 개수가 많거나 주 키로 사용할 적절한 컬럼이 없는 경우,
  일련번호와 같은 임의의 컬럼을 추가하여 PK로 만든다.
  - 예1) 게시물 첨부파일(파일명, 등록일)
    - 파일명이 중복될 수 있다.
    - 파일명과 등록일을 묶어서 PK로 사용하기에는 적절하지 않다.
    - 이런 경우 "첨부파일번호" 컬럼을 임의로 추가하여 PK로 설정한다.
    - 결론) 게시물 첨부파일(파일번호, 파일명, 등록일)
  - 예2) 수강신청(수강생이름, 수강생전화, 수강생이메일, 과목명, 결제여부, 결제유형)
    - 주 키로 사용할만한 적절한 컬럼이 없다.
    - 여러 개의 컬럼을 묶어서 주 키로 사용하자니 너무 복잡하다.
    - 이런 경우에도 "수강신청번호"와 같은 임의의 컬럼을 추가하여 PK로 선정하는 것이 좋다.
- 주 키로 선정된 컬럼의 값은 변경될 수 없기 때문에,
  일련번호와 같은 임의의 컬럼을 pk로 사용한다.
  - pk가 아닌 컬럼은 언제든 값을 변경할 수 있다.
  - 예1) 수강생(이름, 나이, 핸드폰, 이메일, 우편번호, 주소, 은행명, 계좌번호, 최종학력, 전공)
    - 핸드폰이나 이메일은 PK로 사용할 수 있다.
    - 그러나 핸드폰이나 이메일은 가끔 변경될 수 있다.
    - 문제는 PK로 지정된 컬럼은 한 번 사용되면 변경할 수 없다는 것이다.
    - 핸드폰과 이메일처럼 나중에 변경될 수 있는 컬럼인 경우 PK로 지정하지 않는 것이 좋다.
    - 그럼 PK 컬럼은 무엇을 사용하는가?
    - 이런 경우 "수강생번호"와 같은 임의의 컬럼을 만들어 PK로 사용한다.
  - 예2) 페이스북에 로그인할 때 이메일이나 전화번호를 사용하지만,
    실제 주키로 사용하는 것은 사용자 일련번호이다.  

### 대체 키(alternate key)
- 후보 키(candidate key) 중에서 PK로 선정된 키를 제외한 나머지 후보 키를 가리킨다.
- 대체 키 예) 
  - 학번 (X) => 만약 학번이 PK로 선정되었다면 대체 키가 아니다.
  - 주민등록번호 (O)  => PK 대신 사용할 수 있는 키를 대체 키라 부른다.
  - 이메일 (O) => PK 대신 사용할 수 있는 키를 대체 키라 부른다.
- 대체 키는 테이블을 정의할 때 Unique 컬럼으로 지정된다.
  - 즉 PK는 아니지만 값이 중복되면 안되는 컬럼이기 때문에 중복되지 않도록 유니크 컬럼으로 지정한다.

### 외래 키(foreign key)
- 다른 릴레이션(테이블)의 PK 값을 저장하는 컬럼.
- FK가 있는 테이블을 자식 테이블(릴레이션)이라 부르고,
  FK가 가리키는 PK컬럼이 있는 테이블을 부모 테이블(릴레이션)이라 부른다.
- 보통 부모-자식 관계를 맺는 테이블이 있을 때, 
  자식 테이블 쪽에 부모 테이블의 데이터를 가리키기 위해 외부키 컬럼을 둔다.
  
## [논리모델]
- 특정 DBMS를 고려하지 않고 수행하는 개념적인 모델링

### 01. 엔티티 식별 및 속성 식별
- 특정 값들의 집합? 시스템에서 다루는 데이터를 식별한다.
- 다른 말로 "테이블"이라고 한다.
- 테이블을 구성하는 값 => 속성(attribute) = 컬럼(column)
- 예:
  - 학생(이름,전화,이메일,주소,...)
  - 강의(강의명,설명,시작일,종료일,강의료,...)
  
### 02. 주 키 선정(Primary Key; PK)  
- 데이터를 구분할 때 사용할 식별자를 지정한다.
- 만약 PK로 지정할 적절한 컬럼이 없거나, 있더라도 여러 개의 컬럼을 묶어서 사용해야 하는 경우 
  surrogate key(대리 키=인공 키) 사용을 고려하라!

- - -
#### 03. 제1정규화 p.403
- 모델링이란 : 데이터 중복을 방지
- 정규화? 데이터 중복을 찾아내어 별도의 테이블로 데이터를 분리시키는 것.
- [한 테이블]에서 [중복 데이터 또는 중복 컬럼]을 [별도의 테이블로 분리]하여 [부모-자식 관계]를 맺는다.
- 데이터를 참조 하는 테이블이 자식테이블이고, 데이터를 갖고 있는 테이블이 부모 테이블이다.
- 자식 테이블에서는 부모 테이블의 데이터를 가리키기 위해 그 데이터의 pk값을 보관해야 한다.
- 이렇게 부모 테이블의 데이터에 대해 PK값을 저장하는 컬럼을 외부키(FK)라 부른다.
- 중복 컬럼? 사진1, 사진2, 사진3
- 중복 데이터? 수강생 데이터, 강의 데이터, 강사 데이터, ...

예)데이터 중복
이름   학력
홍길동 학사
김길동 학사 

### 07. 포함 관계 및 배타적 관계 추가 p.324 ~ 325
- 여러 테이블에 공통으로 포함되는 컬럼이 있는 경우, 별도의 테이블로 정의한다.
  다음 중 하나의 관계로 설정한다.
- 기본 데이터를 저장하고 있는 테이블 쪽을 부모 테이블로 한다.
- 포함 관계
  - 여러 테이블에서 동시에 포함할 수 있는 관계이다.
- 배타적 관계
  - 여러 테이블 중에서 오직 한 개의 테이블만 포함할 수 있는 관계다.  

## 식별 관계와 비식별 관계 p.329, 347~352
### 비식별 관계(non-identifying)
- 자식 테이블의 외부키(FK)가 그 테이블에서 일반 컬럼으로 사용될 때
- 즉 관계를 표현하는 외부키가 그 테이블에서 식별자로 사용되지 않는 것을 말한다.
- FK != PK

### 식별 관계(identifying)
- 자식 테이블의 외부키(FK)가 그 테이블에서 PK 컬럼으로 사용될 때  
- 즉 관계를 표현하는 외부키가 그 테이블에서 식별자로 사용되는 것을 말한다.  
- FK == PK

- 식별관계 : FK가 PK일때
- =단순히 관계가 아니라 식별도함
- =FK가 PK역할도 같이함

### 04. 제2정규화 p.404 ~ 406
- PK가 여러 컬럼으로 이루어진 경우에 수행
- 모든 일반 컬럼은 반드시 PK 컬럼에 종속되어야 한다.
  그렇지 않은 일반 컬럼이 있다면 별도의 테이블로 분리하여 부모-자식 관계를 맺는다.

### 05. 제3정규화 p.406 ~ 408
- 어떤 컬럼이 PK가 아닌 다른 일반 컬럼에 종속되는 경우가 있다면,
  별도 테이블로 분리하여 부모-자식 관계를 맺는다.

  - pk가 바뀔때 바뀌는게 아니라 다른 일반컬럼이 바뀔때 자기자신이 바뀐다
   => 우편번호가 바뀌면 기본주소가 바뀐다 => 실무에서는 주소테이블 안만든다(주소체계는 계속 바뀌기 때문이다)
  
### 06. 다 대 다 관계의 해소 p.348 ~ 352
- 테이블과 테이블 사이에 다 대 다 관계를 형성한다면,
  [일 대 다]의 관계로 변경해야 한다.
- 왜? DBMS는 물리적으로 다 대 다 관계의 데이터를 저장할 수 없다.
- 해결책?
  두 테이블의 관계를 저장할 테이블을 만든다. 
  "관계 테이블" 이라 부른다.
  관계 테이블은 각 테이블과 일 대 다의 관계를 맺는다.  

### 07. 포함 관계 및 배타적 관계 추가 p.324 ~ 325
- 여러 테이블에 공통으로 포함되는 컬럼이 있는 경우, 별도의 테이블로 정의한다.
  다음 중 하나의 관계로 설정한다.
- 기본 데이터를 저장하고 있는 테이블 쪽을 부모 테이블로 한다.
- 포함 관계
  - 여러 테이블에서 동시에 포함할 수 있는 관계이다.
- 배타적 관계
  - 여러 테이블 중에서 오직 한 개의 테이블만 포함할 수 있는 관계다.  

### 08. 관계의 차수 지정 p.321 ~ 324, 329
- 데이터 끼리 상호 관계의 개수를 지정한다.
- 예)
1    : *  (0이상)    => FK 컬럼이 not null 이다.
1    : 1..* (1이상)  => FK 컬럼이 not null 이다.
0..1 : *  (0이상)    => FK 컬럼이 null 허용이다.
0..1 : 1..* (1이상)  => FK 컬럼이 null 허용이다.  


### 09. 유니크(Unique) 컬럼 지정
- PK는 아니지만 PK처럼 중복되어서는 안되는 컬럼이다. 
- 대체 키(alternate key) 컬럼이 유니크 컬럼이 된다.
- 즉 PK로 선정되지 않은 나머지 후보 키는 유니크 컬럼으로 지정하여 데이터가 중복되지 않도록 한다.

pk,uk는 전부 인덱스 자동으로 만듬
fk는 인덱스 자동으로 안만듬

### 10. null 허용 여부 지정
- 필수 입력 컬럼인지 선택 입력 컬럼인지 지정한다.

편집모드 > 널허용

### 11. 인덱스 컬럼 지정
- 데이터를 찾을 때 검색 조건으로 사용할 컬럼을 지정한다.
- 조회 컬럼으로 지정하면 그 컬럼의 값으로 색인표가 자동으로 생성되어
  데이터를 찾는 속도가 빨라진다.
- 장점: select 속도가 빨라진다.
  단점: insert,update,delete 할 때 마다 색인표를 갱신해야하므로 속도가 느리다. 
  
- 검색할때 기준이 되는 컬럼, 과정명으로 색인표를 만들면 과정명을 select할때 속도 빠르다

- - -

## [물리모델] p.345 ~
- 특정 DBMS에 맞춘 물리적인 모델링

### 21. DBMS에 맞춰서 테이블명과 컬럼명을 설정한다.
- DBMS에서 테이블명과 컬럼명을 작성할 때 보통 다음의 규칙에 따라 작성한다.
  예) first name(FST_NM), regist date(REG_DT), teacher assignment(TCH_ASN)
- 단어는 알파벳 3자 또는 4자로 축약해서 표현한다.
- 단어와 단어 사이는 밑 줄( _ )로 표현한다.

### 22. 도메인(domain) 정의 및 적용 p.353 ~
- 비슷한 종류의 컬럼들을 묶어 새 타입으로 정의한다.
- 이점: 타입을 변경할 때 한 번에 여러 컬럼을 변경할 수 있어서 유지보수에 좋다.

- 새자식 도메인
- 우편번호는 0으로 시작할수잇으므로 varchar로한다


### 23. 번호가 자동 증가하는 컬럼을 지정
- 테이블의 PK 중에서 자동으로 증가해야 하는 컬럼을 지정한다.



### 24. 기본 값 및 제약 조건 설정
- 일부 컬럼에 대해 기본 값을 설정한다.
- 일부 컬럼의 값의 범위를 지정한다.

### 포워드 엔지니어링(forward engineering)
- 모델 ----> 코드
- 참고: 리버스 엔지니어링(reverse engineering)
  코드 ----> 모델   


이름옆에 스키마 표시 x
구분기호 none
스키마생성(studydb) 안해도됨 이미 있음
테이블 삭제 코드 체크 > 드롭 코드를 만들어줌

그냥 저장하면 ms949로 저장되니까
crtl a ctrl c
docs > new file > model.sql > 붙

cli에서
model.sql들어있는 방에 가야됨
source model.sql;

- drop table 코드 전부 복사해서 cli하면 가장 자식 테이블 사라짐 > 몇번하면 다날아감


### 정규화
- 데이터가 중복되지 않도록 구조화시키는 것.
- 참고: 역정규화 (실행 속도를 높이기 위해 데이터 중복을 허용하는 것)
  
## 관계: 부모 테이블과 자식 테이블
### 부모 테이블
- 자식 테이블이 참조하는 데이터를 갖고 있는 테이블

### 자식 테이블
- 부모 테이블의 데이터를 참조하기 위해 그 데이터의 PK 값을 갖고 있는 테이블
- 이렇게 부모 테이블의 PK를 저장하는 컬럼을 FK(Foreign Key)라 부른다.

### 외부키(Foreign Key; FK)
- 자식 테이블에서 부모 테이블의 특정 데이터를 가리키는 컬럼이다.
- 반드시 부모 테이블의 PK 컬럼 값을 저장해야 한다.
  다른 일반 컬럼의 값은 사용할 수 없다.


  
  
- - -
db 리뷰 두번 끝나면
샘플데이터를 만들어라
(insert 문을 직접 만들어라)

- - -

# pms-42 트랜잭션

마이바티스에서 트랜잭션은 sqlSession 객체 단위로 관리한다  
그래서 1,2가 한 트랜잭션으로 묶여있다
그러나 프로젝트 작업삭제는 다른 트랜잭션이다
만약 2에서 예외가 발생하면 1,2는 자동으로 취소되고 롤백된다
근데 프로젝트 작업삭제는  당연히 롤백이 안된다(이미 autocommit true로 commit 했으니까 -> autocommit false로하면? 말이안됨)
                      TaskDao - sqlSession - 프로젝트의 작업삭제(autocommit)
 deleteByProjectNo()/               |
[ProjectDeleteCommand]          sqlSessionFactory 
            delete()\               |
                      ProjectDao - sqlSession - 1. 프로젝트의 멤버삭제, 2. 프로젝트 삭제

## DAO 객체에서 트랜잭션을 관리하면 안되는이유
여러 DAO를 묶어서 한단위로 작업할 수 없는 문제가 있기때문
-> 트랜잭션 통제권을 DAO 객체를 사용하는 객체로 넘긴다
-> 즉, Command객체가 트랜잭션을 통제하게 하자
-> 즉, 각각의 DAO는 커밋, 롤백할 권한이없다, 커밋, 롤백은 Command가 한다

Command객체가 아무 DAO객체를 묶어서 트랜잭션을 자유롭게 만들수잇게하자!

DAO가 sqlSessionFactory를 만들기때문에 DAO가 sqlSession을 호출한다 즉 트랜잭션을 통제함
그래서 Command가 [sqlSessionFactory를 만들자(=트랜잭션 시작)] > Dao1가 sqlSessionFactory에게 openSession() 요청 >
Dao에게 sqlSession을 리턴 > DAO가 sqlSession을 call
Command가 DAO2를 call > DAO2가 factory에게 openSession요청 > sqlSession 리턴(근데 아까랑 같은객체임) > DAO가 sqlSession을 call >
[Command가 sqlSession에게 트랜잭션 종료 요청] > [여기서 sqlSession이 커밋!]

그래서
SqlSessionFactory 클래스를 바꿔야함
- startTransaction()
- commit()
위 두개 메서드 추가, 근데 SqlSessionFactory는 우리가 만든 클래스가 아님

그래서 아래 처럼 만듬

### SqlSessionFactory의 Proxy 만들기

MySqlSessionFactory가 SqlSessionFactory를 사용
- startTransaction()
- commit()  
를 MySqlSessoinFactory에 추가

#### Proxy 디자인 패턴
기존 클래스(기존코드)를 손대지 않고 기능을 변경하는 방법
=> 기존 클래스 행세를 하기 => 실제는 기존 코드를 재활용
한국개발자와 미국개발자는 같은 인터페이스 규칙(정보처리기사)을 따라야, 실제일은 미국개발자가함, 한국개발자는 영어로전달(호출)만해줌(한국고객이 영어를 못함)
한국 고객(영어못함) ->(한국어로 호출) 한국개발자(영어함, 정보처리기사 잇음) ->(영어로 호출) 미국개발자(정보처리기사 잇음) 실제일함 => 한국개발자에게 리턴 => 고객에게 리턴


DAO에서 트랜잭션을 제어하는 코드를 없애야한다(commit/rollback)


##### SqlSession의 close()를 바꾸고 싶다 => Proxy 디자인 패턴





- - -

# 에러

## 윈도우 net start mariadb 스타트 안됨
3306? socket 오류 => 누가 3306 포트 쓰고 잇음 => 3306 포트 죽여야됨  
=> ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES) 비밀번호 잘못입력
skip grant? 하고 새 cli 띄우고 root로 접속 후 =>
=> set password=password('1111');

### 윈도우 포트 죽이기
netstat : 실행중인 port 찾기
netstat -a -o : 실행중인 port 표시, 프로세스id(pid) 표시
taskkill /f /pid 1234 : 1234 프로세스id(pid) kill하기

