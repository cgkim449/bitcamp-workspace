# 비트캠프 디지털 컨버전스 기반 UI/UX 프론트 전문 개발자 양성 과정

## 교육기간
2020-07-13 ~2020-12-21

## 교육내용

### 엄

1. 기초
2. 그림

### 1일차

- 개발 입문자 오리엔테이션
- 애플리케이션 개발 소개
- 애플리케이션 개발 도구 설치

### 2일차

- 서버 애플리케이션 개발 도구 설치
- 예제 프로젝트 다운로드 및 빌드
- 톰캣 서버에 배치 후 테스트 수행
- 실행 유형 소개(인터프리터/컴파일/자바방식)

### 3일차

- 비트, 바이트, 메모리, 데이터 저장 구동원리 소개
- 바이트코드 직접 작성 및 프로파일링 확인(javap)
- 작업 폴더를 GIT 저장소로 전환
- github.com에 개인 저장소(bitcamp-workspace) 생성
- github.com에 로컬 저장소를 업로드(push)
- 수업 관련 저장소를 로컬로 다운로드(clone)
- 자바 기본 프로그래밍 학습 프로젝트 생성
    - bitcamp-java-basic 폴더 생성
    - gradle init를 실행하여 프로젝트 폴더를 초기화시킨다.
- 실습
    - Hello2.java : class파일들을 bin폴더로 보내서 관리하자(그냥 컴파일하면 src폴더에 생성되니까)
    - Hello3.java : bin폴더로 보낸 class파일들을 package로 관리하자(bin/패키지)
    - Hello4.java : package로 관리하면 소스파일이 어떤 폴더에 있던 컴파일하면 bin/패키지로 보낼 수 있다.
    > 즉, class파일은 bin폴더에서 package로 관리하자.
    - package 소속 class 실행하기
        - java -classpath [클래스파일있는 폴더] [패키지명 포함 클래스 이름]

### 4일차

- 소스 파일과 클래스 블록, 클래스 파일의 관계
    - com.eomcs.basic.ex01
        - Exam01 : class 
            - 자바프로그래밍의 최소단위(한 소스파일안에 여러 클래스가 있어도 컴파일하면 그 클래스들 각자의 클래스파일이 생성, 소스파일명과 클래스명은 상관없다.)
        - Exam02 : public class 
            1. 다른 개발자들에게 공개한다. 소스파일명과 클래스명이 같아야한다.
            2. 다른 패키지의 클래스들에게 공개한다.(클래스 접근 제어)
                - 클래스를 선언할 때 사용 범위를 조정할 수 있다.
                - public : 다른 패키지의 클래스가 사용할 수 있게 공개한다.
                - (default) : 같은 패키지에 소속된 클래스만이 사용할 수 있다.
        - Exam03 : 문자집합 -encoding UTF-8 : 리눅스나 맥에서는 할 필요없다 
        - Exam04 : method : method 정의가 클래스 실행의 최소 요구사항
- 주석의 종류와 사용법
    - com.eomcs.basic.ex02
        - Exam01 ://, /* */
        - Exam02 :/** */
        - Exam03 :애노테이션 : 컴파일러나 JVM에게 명령하는 주석 (@Override: 기존기능을 재정의하는게 맞냐)

### 5일차
- 리터럴! : 자바 언어로 값을 표현하는 문법
    - com.eomcs.basic.ex03
        - Exam01 : 리터럴의 종류
            - 78은 다양한 진법으로 표현할 수 있으나 출력은  78
            - 3.14는 다양한 부동소수점으로 표현할 수 있으나 무조건 3.14
        - Exam02 : 정수 리터럴
            - 저장범위
                - System.out.println(Integer.MAX_VALUE)
            - 저장방법
                - 부호-크기법(sign-magnitude)
                - 1의보수
                - 2의보수 : 음수 0이 없어서 8비트의 경우 -128까지 저장가능(위에 애들은 -127~-0,0~127), 2^8에서 더해서 구하거나(256+(-31)=225) 1의보수를 구한 다음 1을 더함.)
                0001 1111 = 31
                1110 0001 = 225
                - Excess-K : 부동소수점이던 정수던 상관없이 값이 최소값 0000 0000 부터 최대값 1111 1111까지 정렬되서 대소비교 속도가 빠름(다른 방법들은 정렬이 안됨)
        - Exam03 : 부동소수점 리터럴
            - 유효자릿수 : 4바이트 7, 8바이트 16
            - 유효자릿수라 하더라도 100% 정확하지 않으며, 유효자릿수 넘어가면 반올림되거나, 잘리거나, 17번째 자릿수에서 쓰레기값 생김.
                    [System.out.println(7 * 0.1); //결과: 0.7000000000000001]
                    - 이유
                    - IEEE-754 규격에 따라 부동소수점을 2진수로 바꾸다보면
                        2진수로 정확하게 변환안될때도 있다.
                        CPU, OS, 컴파일러, JVM의 문제가 아니다.
                    - IEEE-754의 방법에 내재되어 있는 문제다.
                    - 해결책
                        - 시스템에서 필요한 만큼 소수점 이하 자리수를 적절히 잘라 사용하라!
            - 저장방법
                - 지수부 : sign-magnitude
                - 가수부 : Excess-K
        - Exam04 : 
            

- 메모리 크기에 따른 부동소수점의 표현범위
- 문자를 저장하는 방법
- 논리값을 저장하는 방법

### 7일차


#### 질문
1. 왜 위에 껀 -128~127, 밑에껀 -127~127
    //- 바이어스 값(K)을 구하는 공식:
    //    K = 2^(비트수 - 1)
    //  예) 8비트일 경우 ---> K = 2^(8 - 1) = 2^7 = 128, 결과 = 128 + 값
    //   1111 1111 = 128 + 127
    //   1111 1110 = 128 + 126
    //   1111 1101 = 128 + 125
    //      ...
    //   1000 0001 = 128 + 1
    //   1000 0000 = 128 + 0
    //   0111 1111 = 128 + (-1)
    //      ...
    //   0000 0010 = 128 + (-126)
    //   0000 0001 = 128 + (-127)
    //   0000 0000 = 128 + (-128)
    //
    //- IEEE 부동소수점 표준에서는 다음의 공식을 사용한다.
    //    K = 2^(비트수 - 1) - 1
    //  예) 8비트일 경우 ---> K = 2^7 - 1 = 127, 결과 = 127 + 값
    //   1111 1111 = 127 + 128
    //   1111 1110 = 127 + 127
    //   1111 1101 = 127 + 126
    //   1111 1100 = 127 + 125
    //      ...
    //   1000 0000 = 127 + 1
    //   0111 1111 = 127 + 0
    //   0111 1110 = 127 + (-1)
    //      ...
    //   0000 0010 = 127 + (-125)
    //   0000 0001 = 127 + (-126)
    //   0000 0000 = 127 + (-127)
2. System.out.println(0xaaaaaaaa); 컴파일됨
   System.out.println(2_863_311_530‬); 컴파일안됨

3. System.out.println(7 * 0.1); //결과: 0.7000000000000001
    어떻게 잘라쓰는지