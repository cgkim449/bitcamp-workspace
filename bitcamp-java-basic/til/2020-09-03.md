#프로젝트22 - 상속 : 일반화(generalization)를 이용한 공통점 분리

##상속
상속을 구현하는 방법에는 전문화(specialization)와 일반화(generalization) 두 가지가 있다

**전문화**   
기존 클래스의 기능을 그대로 활용할 수 있도록 **연결**하고   
여기에 새 기능을 추가하거나 기존 기능을 변경하여 좀 더 특수 목적의 서브 클래스를 만드는 기법이다   

**일반화**   
서브 클래스의 공통 분모를 추출하여 수퍼 클래스로 정의하고 상속 관계를 맺는 것   
클래스를 설계할 때 초보한테는 처음부터 서브 클래스 만들거까지 고려해서 슈퍼클래스를 설계하려면 힘들다   
그러니까 일단 클래스들을 만들고 리팩토링 과정에서 얘네들이 공통점이있으면 그걸 뽑아내자   
보통 일반화를 통해 추출된 수퍼 클래스는 서브 클래스에게 공통 분모를 상속해주는 것이 목적이다   
즉, 직접 인스턴스를 생성하고 사용하기 위해 만든 클래스가 아니다   
그래서 일반화를 통해 도출한 슈퍼 클래스는 보통 **추상 클래스**로 정의한다   

##추상 클래스와 의존성 주입(DI; Dependency Injection)
DI의 목표 : 의존 객체의 교체가 쉬워진다!   
직접 의존 객체를 **생성(new)**하지말고 **밖에서 생성된 의존 객체**를 **생성자**를 통해 주입받자   
이때 생성자의 파라미터에 의존객체의 추상 클래스를
그래야 여러 의존 객체를 주입받을 수 있기 때문이다

###정리
1) 다형적 변수(추상 클래스)의 활용 : 의존객체를 특정클래스로 제한하지않는다!
- 목록을 다루는 데 필요한 의존 객체를 특정 클래스로 제한하지 말고 
- 상위 클래스의 레퍼런스를 사용하여 여러 개의 서브 클래스를 사용할 수 있도록 유연성을 제공하자.  

2) 의존 객체 주입 활용 : 의존객체 교체가 쉬워진다!
- 의존 객체를 이 클래스에서 직접 생성하지 말고 외부로부터 주입 받는다.
- 생성자의 특성을 이용하자.
- 생성자? 객체가 작업하는 데 필요한 기본 값 또는 의존 객체를 준비하는 메서드.


###protected의 두번째 의미

###saver actions : @Override 자동으로 생긴다


#프로젝트23 - 추상 클래스와 추상 메서드
추상 클래스(abstract class)의 뜻 : 객체 못 만든다(new 명령을 통해 인스턴스를 생성할수 없다)
- 추상메서드를 가질 수 있다
- 강제하고 싶다면 추상 메서드로 선언한다

일반 클래스(concrete class)의 뜻 : 객체를 만들 수 있다

-----------------------------------------------------------------
oop.ex10

###a
A obj = new A(); // 추상 클래스는 인스턴스를 생성할 수 없다, 단순히 레퍼런스는 가능하다!

A : abstract 메서드, C : constructor, 노란색 : ?, 초록색 : 퍼블릭

###c
템플릿 메서드 : 기본적인 실행 흐름은 정의하고 구체적인 행위는 서브 클래스에게 위임하는 설계 기법     
전체적인 논리 흐름을 정의하고(예: build()),   
서브 클래스에서 각 흐름에 따라 구체적인 동작을 정의한다   
(탬플릿 메서는 추상 클래스에 있다, 나머지 구체적인건 서브 클래스 너네들이 알아서 각자 정의해라)

```java
public void introduce() {
  greet();
  say();
  fighting();
}

public abstract void greet();
public abstract void say();
public abstract void fighting();
```
-------------------------------------------------------
oop.ex09 인터페이스   

###a
callee 클래스들과 caller 클래스 간의 메서드 **호출규칙을 정의**하는 문법이 인터페이스이다   

###b
인터페이스에 정의하는 메서드는 호출 규칙이다   
규칙은 공개되어야한다. public   
규칙은 클래스가 따라야한다. 따라서 몸체는 구현하지 않는다 abstract   
따라서 인터페이스의 메서드는 모두 public abstract이다
그리고 클래스는 인터페이스의 메서드의 공개범위를 좁힐 수 없다

인터페이스는 규칙으르 사용되기 때문에   
추상클래스는 ~으로 사용되기 때문에   
new 명령어로 인스턴스를 생성할 수 없다   
따라서 인터페이스의 모든 변수는 static   
그리고 규칙은 공개되어야하며 변경되면 안된다  public final   
따라서 인터페이스의 변수는 public static final이며 static블록을 둘 수 없다   

###c


-------------------------------------------------------
protected 메서드를 (예: Object의 clone())